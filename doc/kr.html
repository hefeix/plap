<center><h1>A System for Learning and Reasoning about Programs:
Declarative Knowledge</h1></center>


semantics-altering transformations
  replacement (incl req - fitness neutrality - as a special case)
semantically neutral transformations
  abstraction
    (H E1 .. En) -> (let [f $v1 ... $vn = H $v1 ... $vn] (f E1 ... En)
  case distribution
    f(cond(res1 .. resN)) <--> cond(f(res1) ... f(resN))
  embedding
    (let [f $v1 ... $vn = rhs] (exp))
    generalizes type of f (e.g. adds an argument or changes an argument type to
    lists), then changes rhs and exp accordingly

how would recursion arise??

mutually exclusive transformations - group as a knob

will we blow memory reqs?

lazy_plus(lazy_plus(_1, 3), lazy_plus(_2, _1))
bind(plus<int>(),bind(plus<int>,_1,3),bind(plus<int>(),_2,_1))

*********

let X be the initial solution
while termination criterion not met:
  if all neighbors of X have be visited or stuck_flip:
    kick
  else if metropolis_flip:
    let X' be a random neighbor X
    if X' is an improvement or metroplis_noise_flip:
      let X be X'
  else
    let X' be a random neighbor of X with highest expected utility
    if X' is an improvement or best_first_noise_flip:
      let X be X'

A number of generalizations of such schemata have been made, most notably to
schemata defined over trees and variable-length strings, by Poli and
Langdon~\cite{FOGP}, along with some extremely complex math (schema theorems).


****************


<blockquote>Fuzzy Sets are - quite obviously, to anyone trained in Bayesian
inference - crude approximations to Bayesian prior probabilities. They were
created only because their practitioners persisted in thinking of probability
in terms of a "randomness" supposed to existing in Nature but never well
defined; and so concluded that probability theory is not applicatable to such
problems. As soon as one recognizes probability as the <i>the general way to
specify incomplete information</i>, the reason for introducing Fuzzy Sets
disappears.</blockquote>

how to indicate which observations come from which sources? use contexts, or
maybe tag with sources

Level of indirection - observed_foo blork := bla, observed_foo gives evidence
of foo. But then when does the above get used?

taging with sources  a derived from b derived from c ...

introduce <tt>effort</tt> type


<h4><u>Declarative vs. Procedural</u></h4>

Roughly speaking, the left-hand side of a declaration (<tt>foo</tt> in <tt>foo
:= bar</tt>) is declarative, while the right-hand side is procedural. Purely
declarative knowledge is hence represented by <i>facts</i> - declarations with
no procedural content (formally a fact is a declaration of a function that maps
to <tt>unit</tt>).<br><br>

The sort of information that is intended to be stored as facts includes:
<ul>
  <li>type: "Birds are animals."</li>
  <li>element: "Tweety is a bird."</li>
  <li>attribute: "Ravens are black."</li>
  <li>identification: "The morning star is Venus."</li>
</ul>
(examples taken from Pei Wang's <u>Rigid Flexibility</u>).  

give examples of temporal and perceptual knowledge


<h4><u>Examples</u></h4>

tall jim := true
vs

"90% of all men are tall" vs. "all men are tall to exactly degree .9" vs.
"the average degree of tallness over all men is 0.9"


tall^1
predicate tall

forall $x ((man $x) -> ($tall $x)) (tv: 0.9)
forall $x ((man $x) -> ($tall $x (tv: 0.9)))

"A classical poser for the reader who wants to solve these difficulties to 
ponder is, 'George IV wondered whether the author of the Waverly novels 
was Walter Scott' and 'Walter Scott is the author of the Waverly novels', 
from which we do not wish to deduce, 'George IV wondered whether Walter 
Scott was Walter Scott'. This example and others are discussed in the first 
chapter of Churchâ€™s Introduction to Mathematical Logic (1956)." - McCarthy 69

belive self x iff x

Facts are used to declare relationships such as the folowing:

give ben's pln marbles examples

give copycat example


<h5>Higher-order statements</h5>
<ul>

  <li>"John knows that whale is a kind of mammal."<br>
  <tt>knows john (inh whale mammal);</tt></li>

</ul>

<h5>Transitivity</h5>

The transitivity property itself should actually be defined procedurally, i.e.
<ul>

  <li>"A binary relation R is transitive if for all x, y, and z in its domain,
  xRy and yRz imply xRz."<br>
  <tt>(transitive R) && (R x y) && (R y z) 

  forall R:('a 'a -> bool) x y z where (transitive R) && (R x y) && (R y z) :=
  R x z;
  
  <li>"The function plus is associative and commutative"<br>
  <tt>associative plus; commutative plus;</tt></li>

  <li>"The function foo is probably <br>
  <tt></tt></li>

    <li><br>
  <tt></tt></li>


    <li><br>
  <tt></tt></li>



inh ben ugly := tv 0.4 0.8;

should there be a default (universal) "tall jim" value, or just "context humans
(tall jim)"?

the need is to distinguish between "it is very likely that jim is somewhat
tall" and "it is somewhat likely that jim is very tall"

believes matt (= (is_flat earth) (tv 0.9 0.2)) ? (tv 0.4 0.66);



need more examples of concepts:
* furniture (contextual)
* opposite

let's say a secondary meaning of "person" is introduced that is identical to
the current meaning of "turnip", and that this secondary usage is encountered
1/3 of the time by the agent (weighted by importance). Then the belief value
attached to current inheritance links to person would all need to be muliplied
by 2/3 (does the math support this???), with a corresponding increase in
disbelief.


a believes that b believes that ...

* completely certain that the two teams in tomorrow's game are evenly matched
winner team_a ? (0.5 0.5 0);

* no idea who will win
winner team_a ? (0 0 1);


* unknown value of a coin flip given complete certainty that coin is fair
result heads ? (0.5 0.5 0);

* unknown value of a coin flip given complete certainty that coin is either
  two-headed or two-tailed
coin two_headed ? (0.5 0.5 0)
coin two_tailed ? (0.5 0.5 0)
given (coin two_headed) (result heads);
given (coin two_tailed) (result tail);

> result heads heads ?;
0.5 0.5 0

* unkown value given complete uncertainty
result heads ? 

* weak evidence that jim is very tall
is_tall jim := 0.9 ? (0.1 0 0.9)

* certain jim is of medium height
is_tall jim := 0.5 ? 

* no idea what jim's height is

* jim is either very tall or very short


* jim is definitely not "very tall"
is_taill jim := 0.9 (0 1 0)

90% chance you have a mild cold

********


******

"In the context of sex,
beauty-as-interpreted-in-the-context-of-mathematics is largely
irrelevant."

But it seems OK to handle this obscure case via higher-order
constructs, so that e.g.
beauty-as-interpreted-in-the-context-of-mathematics would be
represented as something like

SatisfyingSet
   Inheritance $X beauty
   InContextOf mathematics $X

where the "InContextOf" predicate is a sort of "virtual ContextLink"
that must be grounded in an appropriate AtomTable lookup involving
VersionHandles.

**********

>
> Evaluation believe Matt (Hyp (Inheritance Earth flat))
>
> is given. However, I think that the Hyp marker has to be attached to
> "Matt believes" as well, no?

No, that would be conceptually wrong....  Matt's belief is part of the
"default knowledge space" of the system, it's not hypothetical.

> Otherwise, how can you represent that Matt
> is certain that Earth is completely flat (believes it with a tv <1,1>),
> whereas Moshe thinks that the Earth may be fairly flat (believes it with
> tv <0.8,0.5>). The other way to do it would be to have two "(Hyp
> (Inheritance Earth flat))" links with different truth-values (one for
> Matt's belief and one for Moshe's), which was decided against, IIRC...

The core, right now, supports multiple versions of (Inheritance Earth flat)
in the Hypothetical AtomTable.

However, as we discussed recently on this list, this solution is not really
optimal, and we need to replace it with an alternate approach.  The
alternate we decided on was to use CompositeTruthValue objects,
each one of which contains multiple TV's indexed by globally-scoped
VersionHandles.

But these implementation details are really part of NM, not PLN.

The point from a PLN perspective is: yeah, different hypothetical
versions of the same Atom must be considered as having potentially
different TV's.

************

Cassio Pennachin wrote:
> > Hi,
> >
>> >> Mainly we discussed in more depth than before, the handling of
>> >> Hypothetical and Contextual relationships
>> >> using VersionHandles.  This seemed to us to require a minor change to
>> >> the VersionHandle design.
> >
> > Which seems to be the introduction of the contextual x hypothetical 
> > indicator, right?  Why is that necessary?
> >
> > Cassio
> >
> >

Well, we decided to get rid of HypotheticalLink and ContextLink...

So, then, in my proposal

HypotheticalLink A B

is represented by

A [H]
B [H1 , hypothetical H]

and

ContextLink A C

is represented by

A [H]
C [H2 , contextual H]


For instance, let

P = the set of things that Pei believes [H]

Then

Pei believes the earth is flat

is represented by

the earth is flat [H1, hypothetical H]

but

In the context of Pei's beliefs, computer science is trivial

is represented by

computer science is trivial [H2, contextual H]

If we get rid of the hyp vs. contextual marker, then there would be no 
way to tell that the latter
represents a ContextLink and the former represented a HypotheticalLink, 
since the Handle H
of the embedding Atom P is the same in both cases...

************

They are.  But if we're going to use timestamps as VersionHandles (a  
possibility we're considering, as it saves a lot of space in the  
representation of temporal data) we have no way to distinguish these  
from the real Atoms.
